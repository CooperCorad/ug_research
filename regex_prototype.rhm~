#lang rhombus/static/and_meta

import:
  lib("racket/base.rkt") as base
  file("character_class_lang.rhm").c_range
  file("character_class_lang.rhm").c_range_meta
 
  file("character_class_lang.rhm") open
  //file("character_class_lang.rhm").#%brackets
  //file("character_class_lang.rhm")

export:
  // The main form:
  rx
  regexp
  meta: regexp_meta

  // Operators for use inside `rx'...'`:
  //any newline
  || * ? + ^ $ ! word in only 
  if matches not property ~~
  - -- && ^

  // Implicit operators, like the one before a literal string;
  // we use `names` here so that these names are not
  // misinterpreted as implicits in the `export` sublangauge!
  names: #%literal #%comp #%parens #%juxtapose #%call #%brackets #%index


  // API functions
  rx_match rx_match_as_list rx_try_match
  pregexp rx_quote
  rx_match_positions rx_match_positions_as_list
  rx_is_match rx_is_exact_match
  rx_max_lookbehind
  rx_split rx_replace rx_replace_all
  

// Example regexps
#//
module test:
  check:
    rx'^ ("Hello" || "Hi") " "? ("Here"||"There") $'
    ~completes
  check:
    rx'(^ "Hello" || "Hi"{1, 22} || "At("any*")") $'
    ~completes
  #// Come back?
  #//
  check:
    rx'  (! any)+'
    ~completes
  check:
    import lib("racket/base.rkt").#{regexp-match?}
    def p = rx'"apple" || "banana"'
    #{regexp-match?}(p, "apple") && #{regexp-match?}(p, "banana")
    ~is #true



  check:
    def p1 = rx'"drone" in word'
    def words = "dronemusic"
    rx_is_match(p1, words)
    ~is #true
  check:
    import lib("racket/base.rkt").#{regexp-match?}
    def p2 = rx'"drone" word bound'
    def words = "dronemusic"
    #{regexp-match?}(p2, words)
    ~is #false
  check:
    def p2 = rx'"drone" word bound'
    def words = "drone music"
    rx_is_match(p2, words)
    ~is #true
  check:
    def p1 = pregexp(rx'(mode : {insensitive, multiline} : "a")') 
    def p2 = base.#{pregexp}("(?im:a)")
    p1 == p2
    ~is #true
    

// Instantiate enforestation and macro machinery for the
// regexp sublanguage:
space.enforest regexp:
  space_path rhombus/regexp
  macro_definer macro
  bridge_definer bridge
  meta_namespace regexp_meta:
    description "regexp"
    parse_syntax_class Parsed
    parsed_packer do_pack
    parsed_unpacker do_unpack
    reflection reflect
    // This recursive parsing is what the default checker does:
    #//
    parse_checker: fun (stx, who):
                     match stx
                     | _ when do_unpack(stx, fun (x): #false): stx
                     | (_ :: Syntax) && '$(next :: regexp_meta.Parsed)': next
                     | _: syntax_meta.error("bad result", stx)
    // Improve the error for an identifier that isn't an operator
    identifier_parser id_parse

    export pack unpack reflect

    fun pack(s :: String) :: Syntax:
      do_pack(s)
    fun unpack(stx) :: String:
      do_unpack(stx, #false).unwrap()
    fun id_parse(id):
      match id
      | 'any':
          regexp_meta.do_pack(".")
      | 'newline':
          regexp_meta.do_pack("\n")
      | 'space':
          regexp_meta.do_pack(" ")
      | ~else:
          //statinfo_meta.unpack(id)
          syntax_meta.error("invalid id " +& id)

expr.macro '«rx '$(pat :: regexp_meta.Parsed)'»':
  //import lib("racket/base.rkt").#{pregexp}
  //let pat = regexp_meta.unpack(pat)
  //'values($pat, $(#{pregexp}(pat)))'//TODO convert to string? let API handle pregexp etc.
  statinfo_meta.wrap('$(regexp_meta.unpack(pat))','((z, $(regexp_meta.unpack(pat))))')

regexp.macro'$left #%index [$c_rng]':
  ~stronger_than #%juxtapose
  let '$(c_rng :: c_range_meta.Parsed)' = '[$c_rng]'
  regexp_meta.pack(regexp_meta.unpack(left) +& c_range_meta.do_unpack(c_rng).unwrap())

regexp.macro '#%brackets [$c_rng]':
  ~stronger_than #%juxtapose
  let '$(c_rng :: c_range_meta.Parsed)' = '[$c_rng]'
  regexp_meta.pack((c_range_meta.do_unpack(c_rng)).unwrap())

macro '$left eq? $right':
  'check:
     import lib("racket/base.rkt")
     def p1 = base.#{pregexp}($left)
     def p2 = base.#{pregexp}($right)
     p1 == p2
     ~is #true'

module test:
  rx'["a"-"b"]' eq? "[a-b]"
  rx'[^"av"-"x"]' eq? "[^av-x]"
  rx'["a""b"]' eq? "[ab]"
  //["."] eq? "[\\.]" //TODO
  //["."-"z"] eq? "[\\.-z]"
  rx'["2"]' eq? "[2]"
  rx'["a"-"bc"-"d"]' eq? "[a-bc-d]"
  rx'["a"-"b""c"-"d"]' eq? "[a-bc-d]"
  rx'["a"-"z" -- "x"]' eq? "[a-wy-z]"
  rx'["a"-"z" -- "f"-"h"]' eq? "[a-ei-z]"
  
  rx'["a"]' eq? "[a]"
  rx'["a"-"b"]' eq? "[a-b]"
  rx'[^"a"]' eq? "[^a]"
  rx'["a""b"]' eq? "[ab]"
  rx'["a""x"-"y"]' eq? "[ax-y]"
  //["b"-"a"] 
  rx'["a"-"z"&&"x"-"y"]' eq? "[x-y]"
  //["b"-"a" && "a"-"z"]
  rx'["a"-"z" && "xyz"]' eq? "[xyz]"
  rx'["a"-"z"&&"b"-"k"]' eq? "[b-k]"
  rx'[^"^"]' eq? "[^\\^]"
  rx'["abc" && "a"-"y"]' eq? "[abc]"

//bind macro -> pull static info as bound info, static info key, and static lookup on escape - static info lookup

        
  
module test:
  def a = rx'["0"-"9"]{0, 3}'
  // -> def a = rx'[0-9]{0,3}'
  // -> statinfo.macro 'a':
  //      '(($z
  def b = rx'$a'
  rx' $b + '

  def n0_255 = rx' ~~([digit] \
                      || [digit][digit] \
                      || ["01"][digit][digit] \
                      || "2" ["0" - "4"] [digit] \
                      || "25" ["0" - "5"])'
  rx'$n0_255'
  rx'$n0_255 || $n0_255'
  //rx'$n0_255 $n0_255' <-- does not work?? precedence levels! TODO

statinfo.key z:
  ~union: fun(s1, s2):
            s1 && s2
  ~intersect: fun(s1, s2):
                s1 || s2

regexp.macro
| '$left $('$')':
    ~weaker_than: #%juxtapose #%call
    ~same_as: ^
    regexp_meta.pack(regexp_meta.unpack(left) +& "$")
| '$('$')$(id :: Identifier)':
    ~same_as: ^
    regexp_meta.pack("(?:" ++ (statinfo_meta.lookup(id, 'z') :~ Syntax).unwrap() ++ ")")

// API
/* TODO:
    - enforce types? just annotations?
    - byte-(p)regexp support?
    - convert most function generation into a macro function generator?
    - avoid repeated imports on function calls?
*/

//TODO -> some form of string + arr[matches], maybe simplifies to just a String as needed
fun rx_match(px, input,
             ~start_pos = 0,
             ~end_pos = #false,
             ~output_port = #false,
             ~input_prefix = #""):
  match base.#{regexp-match}(base.#{pregexp}(px), input, start_pos, end_pos, output_port, input_prefix)
  | (m :: PairList) :
      for List (match : m):
                  to_string(match)
  | ~else: #false

fun rx_match_as_list(px, input,
                     ~start_pos = 0,
                     ~end_pos = #false,
                     ~input_prefix = #""):
  def matches :~ PairList = base.#{regexp-match*}(base.#{pregexp}(px), input, start_pos, end_pos, input_prefix)
  for List (m : matches):
    to_string(m)

fun pregexp(px):
  base.#{pregexp}(px)
    
fun rx_try_match(px, input,
                 ~start_pos = 0,
                 ~end_pos = #false,
                 ~output_port = #false,
                 ~input_prefix = #""):
  match base.#{regexp-try-match}(px, input, start_pos, end_pos, output_port, input_prefix)
  | (m :: PairList): to_string(m[0])
  | ~else: #false

 
fun rx_match_positions(px, input,
                       ~start_pos = 0,
                       ~end_pos = #false,
                       ~output_port = #false,
                       ~input_prefix = #""):
  base.#{regexp-match-positions}(px, input, start_pos, end_pos, output_port, input_prefix)

fun rx_match_positions_as_list(px, input,
                               ~start_pos = 0,
                               ~end_pos = #false,
                               ~input_prefix = #""):
  base.#{regexp-match-positions*}(px, input, start_pos, end_pos, input_prefix)


fun rx_is_match(px, input):
  base.#{regexp-match?}(base.#{pregexp}(px), input)

fun rx_is_exact_match(px, input):
  base.#{regexp-match-exact?}(px, input)

fun rx_quote(str,
             ~case_sensitive = #true):
  to_string(base.#{pregexp-quote}(str, (case_sensitive)))

fun rx_max_lookbehind(px):
  base.#{regexp-max-lookbehind}(px)

fun rx_split(px, input,
             ~start_pos = 0,
             ~end_pos = #false,
             ~input_prefix = #""):
  def matches :~ PairList = base.#{regexp-split}(base.#{pregexp}(px), input, start_pos, end_pos, input_prefix)
  for List (m : matches):
    to_string(m)

fun rx_replace(px, input, insert,
               ~input_prefix = #""):
  to_string(base.#{regexp-replace}(px, input, insert, input_prefix))

fun rx_replace_all(px, input, insert,
                   ~start_pos = 0,
                   ~end_pos = #false,
                   ~input_prefix = #""):
  to_string(base.#{regexp-replace*}(base.#{pregexp}(px), input, insert, start_pos, end_pos, input_prefix))



// `#%literal` is implicitly added before literals, like strings,
// that do not have an operator before
// TODO revert to old?
// old

regexp.macro '#%literal $(s :: String)':
  import lib("racket/base.rkt").#{regexp-quote}
  regexp_meta.pack(to_string(#{regexp-quote}(s.unwrap())))
#//
regexp.macro '#%literal $(s :: String)':
  regexp_meta.pack(base.#{pregexp-quote}(s.unwrap()))

// `#%parens` is implicitly added before parentheses
// that do not have a parsed term or operator before
regexp.macro
| '#%parens (if $tst ... | $(then :: regexp_meta.Parsed) | $(else :: regexp_meta.Parsed))':
    let '$(tst :: regexp_meta.Parsed)' = '$tst ...' // TODO move then and else to similaer forms to avoid out of order parsing -> error issues
    regexp_meta.pack("(?" ++ regexp_meta.unpack(tst) ++ regexp_meta.unpack(then) ++ "|" ++ regexp_meta.unpack(else) ++ ")")
| '#%parens (mode : {$(mode :: Identifier), ...} : $(rgxp :: regexp_meta.Parsed))':
    //~same_as ^
    //def mutable accum = "(?"
    def modes = (for values(accum = "(?") (m: [mode, ...]):
                   match m
                   | 'sensitive': accum +& "-i"
                   | 'insensitive': accum +& "i"
                   | 'multiline': accum +& "m"
                   | 'monolne': accum +& "-m"
                   | ~else: syntax_meta.error("mode: " ++ m ++ " not recognized"))
    regexp_meta.pack(modes +& ":" ++ regexp_meta.unpack(rgxp) ++ ")")
    
| '#%parens (matches prev $(tst :: regexp_meta.Parsed))':
    regexp_meta.pack("(?<=" ++ regexp_meta.unpack(tst) ++ ")")
| '#%parens (not matches prev $(tst :: regexp_meta.Parsed))':
    regexp_meta.pack("(?<!" ++ regexp_meta.unpack(tst) ++ ")")
| '#%parens (matches $(tst :: regexp_meta.Parsed))':
    regexp_meta.pack("(?=" ++ regexp_meta.unpack(tst) ++ ")")
| '#%parens (not matches $(tst :: regexp_meta.Parsed))':
    regexp_meta.pack("(?!" ++ regexp_meta.unpack(tst) ++")")
    
| '#%parens ($(n :: Int))':
    unless n is_a PosInt  //TODO: does racket allow \0 backref or does it start at \1?
    | syntax_meta.error("You cannot check a match on capture group number <= 0")
    regexp_meta.pack("(" ++ n ++ ")")
| '#%parens ($(p :: regexp_meta.Parsed))':
    regexp_meta.pack("(" ++ regexp_meta.unpack(p) ++ ")")

//TODO: rework syntax, looks ugly
regexp.macro '~~( $(p :: regexp_meta.Parsed) )': // ~uncaptured
  regexp_meta.pack("(?:" ++ regexp_meta.unpack(p) ++ ")")
#//
regexp.macro '$(kw :: Keyword): ( $(p :: regexp_meta.Parsed) )':
  unless kw.
  regexp_meta.pack("(?:" ++ regexp_meta.unpack(p) ++ ")")

#//
module test:
  check:
    def p1 = rx'(if (matches "x"+) | "a" | "b")'
    ~completes

  check:
    def p1 = pregexp(rx'(matches "X"+)')
    def p2 = base.#{pregexp}("(?=X+)") //TODO once again issues with atomic?
    p1 == p2
    ~is #true
  
  check:
    def p1 = pregexp(rx'(not matches "X"+)')
    def p2 = base.#{pregexp}("(?!X+)") 
    p1 == p2
    ~is #true
  
  check:
    def p1 = pregexp(rx'(matches prev ("y")("X"))')
    def p2 = base.#{pregexp}("(?<=(y)(X))") 
    p1 == p2
    ~is #true
    
  check:
    def p1 = pregexp(rx'(not matches prev ("X"))')
    def p2 = base.#{pregexp}("(?<!(X))") 
    p1 == p2
    ~is #true
    
  #//
  check:
    ~eval
    rx'("x")(0)'
    ~throws "backreference"
regexp.macro 'not property : $(prop :: Identifier)': // TODO not property {x} vs. property {^x} --> necessary to keep both?
  regexp_meta.pack("\\P{" ++ to_string(prop) ++ "}") // additionally, does the not <x> thing feel tired? alternative?
regexp.macro 'property : $(prop :: Identifier)':
  regexp_meta.pack("\\p{" ++ to_string(prop) ++ "}")
#//
module test:
  check:
    def p1 = pregexp(rx'property : Ll')
    def p2 = base.#{pregexp}("\\p{Ll}")
    p1 == p2
    ~is #true

  check:
    def p1 = pregexp(rx'not property :Ll')
    def p2 = base.#{pregexp}("\\P{Ll}")
    p1 == p2
    ~is #true

// `#%juxtapose` is implicitly added after something that's
// parsed and before a non-operator
regexp.macro '$left #%juxtapose $right':
  ~same_as: #%call
  regexp_meta.pack("" ++ regexp_meta.unpack(left) ++ regexp_meta.unpack(right))

//rx'["a"-"b"]'

// `#%call` is implicitly added between a parsed term
// and parentheses; we want just the same thing
// as juxtaposition here, though
regexp.macro '$left #%call $tail ...':
  ~same_as: #%juxtapose
  values('$left', '#%juxtapose $tail ...')

meta:
  fun atomic(stx) :~ String:
    match regexp_meta.unpack(stx)
    | ".": "."
    | s: to_string(s) // TODO: originally s: "(?:" ++ s ++ ")" better?

regexp.macro
| '$left || $right':
    ~weaker_than: ~other
    ~stronger_than: !
    regexp_meta.pack(atomic(left) ++ "|" ++ atomic(right)) // TODO: atomic needed? likely no!
//| '$left ||; $(right :: regexp_meta.Parsed)':
//    regexp_meta.pack(atomic(left) ++ "|" ++ atomic(right))

#//
regexp.macro '#%alts $rst':
  [print(rst), ...]
  //regexp_meta.pack(atomic(fst) ++ [ "|" ++ atomic(rst), ...])
#//
rx'| "a"
   | "v"'

regexp.macro
| '$left * lazy':
    ~stronger_than: #%juxtapose #%call
    regexp_meta.pack(atomic(left) ++ "*?")
| '$left *':
    regexp_meta.pack(atomic(left) ++ "*")

regexp.macro
| '$left + lazy':
    ~stronger_than: #%juxtapose #%call
    regexp_meta.pack(atomic(left) ++ "+?")
| '$left +':
    regexp_meta.pack(atomic(left) ++ "+")

regexp.macro
| '$left ? lazy':
    ~stronger_than: #%juxtapose #%call
    regexp_meta.pack(atomic(left) ++ "??")
| '$left ?':
    regexp_meta.pack(atomic(left) ++ "?")
#//
module test:
  rx'"a" + lazy'
  //rx'"?" lazy'
  rx'"a"? lazy'
  rx'"a" lazy'

//'$([^"a"])'
#//
module test:
  check:
    def p1 = pregexp(rx'"zyx"+lazy') //TODO: do we def wrap in parens? or let the user decide when to use? I feel like giving the user the ability is the move
    def p2 = base.#{pregexp}("zyx+?") // e.g. "(zxy)+?"
    p1 == p2
    ~is #true
  
  check:
    ~eval
    rx'"x"++'
    ~raises "" // TODO update

// `#%comp` is implicitly added between a parsed term
// and curly braces
    // TODO LAZY
regexp.macro #%comp:
  ~stronger_than: #%juxtapose #%call
| '$left #%comp {$(min :: Int), _}':
    regexp_meta.pack(atomic(left) ++ "{" +& min.unwrap() ++ ",}")
| '$left #%comp {$(min :: Int), $(max :: Int)}':
    regexp_meta.pack(atomic(left) ++ "{" +& min.unwrap() ++ "," +& max.unwrap() ++ "}")
| '$left #%comp {$(count :: Int)}':
    regexp_meta.pack(atomic(left) ++ "{" +& count.unwrap() ++ "}")

regexp.macro 
| '^ $right':
    ~stronger_than: *
    ~weaker_than: #%juxtapose #%call
    ~same_as: $
    regexp_meta.pack("^" ++ regexp_meta.unpack(right))

regexp.macro '! $right':
  ~weaker_than: ~other
  ~stronger_than: #%juxtpapose #%call
  regexp_meta.pack("(?!" ++ regexp_meta.unpack(right) ++ ")")

regexp.macro '$left word bound':
  ~stronger_than: #%juxtapose #%call
  ~same_as ^
  regexp_meta.pack(atomic(left) ++ "\\b")

regexp.macro '$left in word':
  ~stronger_than: #%juxtapose #%call
  ~same_as ^
  regexp_meta.pack(atomic(left) ++ "\\B")

regexp.macro 'only first $rgxp':
  ~stronger_than ^
  regexp_meta.pack("(?>" ++ regexp_meta.pack(rgxp) ++ ")")

regexp.macro 'numrng: $(lhs :: Int) - $(rhs :: Int)':
  when !(lhs is_a PosInt && rhs is_a PosInt) // || lhs > rhs
  | error("you cannot take ranges of non integers")

//regexp.macro  // (interior) PACK vs UNPACK?, also atomic diff btwn () and (?:)?


//rx'^(mode: {insensitive, multiline}: "a.b"+) ("x"+)*'
//rx' "x"+ || "y"+'